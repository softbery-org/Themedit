// Copyright (c) 2024 Softbery by Paweł Tobis
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/*
 * CA1003: Use generic event handler instances
 * 
 * Note
 * This article applies to Visual Studio 2015. If you're looking for the latest Visual Studio documentation, see Visual Studio documentation. We recommend upgrading to the latest version of Visual Studio. Download it here
 * 
 * TypeName UseGenericEventHandlerInstances
 * CheckId CA1003
 * Category Microsoft.Design
 * Breaking Change Breaking
 * 
 * Cause
 * A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and  the * containing assembly targets.NET Framework 2.0.
 * 
 * Rule Description
 * Before.NET Framework 2.0, in order to pass custom information to the event handler, a new delegate had to be declared that specified a class that was derived from the * System.EventArgs class. This is no longer true in .NET Framework 2.0, which introduced the System.EventHandler<TEventArgs> delegate. This generic delegate allows any class  * that is derived from EventArgs to be used together with the event handler.
 * 
 * How to Fix Violations 
 * To fix a violation of this rule, remove the delegate and replace its use by using the System.EventHandler<TEventArgs> delegate. If the delegate is autogenerated by the * Visual Basic compiler, change the syntax of the event declaration to use the System.EventHandler<TEventArgs> delegate.
 * When to Suppress Warnings
 * Do not suppress a warning from this rule.
 * 
 * Example
 * The following example shows a delegate that violates the rule. In the Visual Basic example, comments describe how to modify the example to satisfy the rule.For the C# * example, an example follows that shows the modified code.*/


namespace SfbLibrary
{
    // This delegate violates the rule.
    public delegate void CustomEventHandler(object sender, CustomEventArgs e);

    public class CustomEventArgs : EventArgs
    {
        public string info = "data";
    }

    public class ClassThatRaisesEvent
    {
        public event CustomEventHandler SomeEvent;

        protected virtual void OnSomeEvent(CustomEventArgs e)
        {
            if (SomeEvent != null)
            {
                SomeEvent(this, e);
            }
        }

        public void SimulateEvent()
        {
            OnSomeEvent(new CustomEventArgs());
        }
    }

    public class ClassThatHandlesEvent
    {
        public ClassThatHandlesEvent(ClassThatRaisesEvent eventRaiser)
        {
            eventRaiser.SomeEvent += new CustomEventHandler(HandleEvent);
        }

        private void HandleEvent(object sender, CustomEventArgs e)
        {
            Console.WriteLine("Event handled: {0}", e.info);
        }
    }

    class Example
    {
        static void MainReturn()
        {
            ClassThatRaisesEvent eventRaiser = new ClassThatRaisesEvent();
            ClassThatHandlesEvent eventHandler = new ClassThatHandlesEvent(eventRaiser);

            eventRaiser.SimulateEvent();
        }
    }
}
